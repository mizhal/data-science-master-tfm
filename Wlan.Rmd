---
title: "Exploración2"
author: "Miguel Pérez Barrero"
date: "21/11/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## TFM

### Librerías y dependencias

```{r Librerías}
library(tidyr)
library(dplyr)
library(ggplot2)
library(visdat)
library(data.table)
library(graphics)
library(tibble)
```

### Carga de datos

```{r Carga de datos}
positions_wifi_space <- read.csv("positions_wifi_space.csv")
to_cluster <- positions_wifi_space
to_cluster$position_id <- NULL
to_cluster$unix_time <- NULL
to_cluster$time <- NULL
to_cluster$user_id <- NULL
```

Visualizamos la varianza de las dimensiones.

```{r}
library('resample')
barplot(colVars(to_cluster))
```
Se puede ver que hay mucha diferencia en las varianzas de las dimensiones. En estos casos K-medias no suele funcionar muy bien por [referencia 8].

Se prueban otros algoritmos de clustering.

Se intenta visualizar la forma de la nube con un SOM (Mapa autoorganizado de Kohonen), que además nos ayuda a clusterizar.

```{r}
library('kohonen')
map <- som(as.matrix(to_cluster), somgrid(xdim = 100, ydim = 100, topo = c("hexagonal")))
```

```{r fig.width = 15, fig.asp=1}
plot(map, type = 'mapping', main="Asignación de muestras a los 'cuantos' de SOM")
```

```{r}
saveRDS(map, "WIFI_SOM.RData")
```

En el mapa del SOM se pueden distinguir clusters a simple vista, lo que nos permite visualizar mejor que existen, aunque era algo que ya se intuia al ser los datos de señal wifi provenientes de un espacio físico.

```{r}
set.seed(7)

error <- NULL
k_max <- 40

for (i in 2:k_max)
{
  error[i] <- sum(kmeans(som.events, centers = i, iter.max = 100, nstart = 10)$withinss)
}

plot(1:k_max, error, type="b", xlab="Cantidad de Cluster", ylab="Suma de error")
```

Parece que la rodilla está en 10 clusters. Vamos a usar ese valor.


```{r fig.width = 15, fig.asp=1}
set.seed(8)
k <- 10
som.cluster.k <- kmeans(som.events, centers = k, iter.max = 100, nstart = 10)$cluster

plot(map,
     type = 'mapping',
     keepMargins = F,
     bgcol = rainbow(10)[som.cluster.k],
     bg = 0,
     main = 'Mapa con clusters')
add.cluster.boundaries(map, som.cluster.k)
```
Se puede ver que los clusters "densos" marcados en negro se agrupan y atraen parte de la zona de alrededor.
Pienso que la distribución que se muestra es razonable.

Con estos 10 clusters vamos a codificar todas las trazas de ubicación wifi.
Ahora se etiqueta la tabla de posiciones_wifi con el resultado del cluster que corresponde.

```{r Creación del conjunto etiquetado con las ubicaciones}
wifi_pos_labeled <- positions_wifi_space
wifi_pos_labeled$location <- som.cluster.k[map$unit.classif]
saveRDS(wifi_pos_labeled, "wifi_pos_labeled.RData")
write.csv(wifi_pos_labeled, "wifi_with_location.csv", row.names = FALSE)
```

Vemos el porcentaje de puntos en cada ubicación

```{r message=FALSE}
por_ubicacion <- wifi_pos_labeled %>% group_by(location) %>% summarise(sum = n())
pie(por_ubicacion$sum)
```

Vamos a explorar la distribución temporal de los eventos de wifi

```{r}
library(gdata)
library(dplyr)
library(lubridate)

# ultimo domingo de 2007 como fecha base para que las semanas sean regulares entre años
base <- parse_date_time('2007/12/30 00:00', 'y-m-d H:M')

time_distibution_wlan <- wifi_pos_labeled  %>% mutate(
               time = parse_date_time(time, "y-m-d H:M:S")
             ) %>%
             mutate(
                weekday = wday(time), 
                week = as.integer(round(difftime(time, base, units = "weeks"))),
                year_week = week(time),
                hour = hour(time),
                month = month(time), 
                year = year(time),
                year_day = yday(time)
             ) %>% filter(year >= 2008) %>% arrange(week, user_id)
```

Ahora hacemos un resumen informativo de donde suelen estar los usuarios en los diferentes momentos del día. Para evitar alteraciones, vamos mirando los perfiles limitados por semana. Si no hacemos esta limitación por semana, los perfiles se aplanan y no dan información.

```{r}
plots <- list()
for(loc in 1:10) {
  per_hour <- time_distibution_wlan %>% 
                dplyr::select(user_id, location, week, year_week, weekday, hour) %>% 
                distinct(user_id, location, week, year_week, weekday, hour) %>% 
                filter(location == loc) %>% 
                filter(year_week == 2)
  plots[[loc]] <- ggplot(per_hour, aes(x=hour)) +
    geom_histogram(color="black", fill="white", binwidth = 1) +
    xlab("Hora") +
    ylab("Visitas") +
    ggtitle(paste0("Ubicación ", loc))
}

wrap_plots(plots)
```

Se pueden observar diferencias entre las ubicaciones, algunas notables.
La ubicación 1 es más frecuentada por las noches aunque tiene gente por el día, es probable que sea un lugar cercano a los dormitorios o un área comun.
La dos es más frecuentada hacia el centro del día, pueden ser clases u oficinas.
La tres es frecuentada hacia la tarde - noche pero no de madrugada, podría ser una cafetería o zona de ocio.
La cuatro tiene visitas regulares durante todo el día, con momentos puntuales de madrugada y de 5 a 6. Podría ser también zona de dormitorios.
La 5 parece que solo se frecuenta para dormir o para ocio de tarde-nocturno.
La 6 es más frecuentada temprano en el día y la madrugada. También podría ser un tipo de oficina o clase.
Un perfil similar tienen la 7 y la 8.
La 9 es frecuentada durante la tarde y la madrugada, podría ser otro área de dormitorio.
La 10 tiene un aumento de visitas esporádicas a ciertas horas, podría ser una zona de tránsito. 

### Crear la matrix de eventos wifi con la rejilla agrupada por semana

Primero se calcula la tabla de usuario, semana y ubicación/cluster

```{r}
wlan_by_week <- time_distibution_wlan %>%
                group_by(week, user_id, location) %>%
                summarize(count = n())
head(wlan_by_week)
```

Ahora se crean los pares de usuarios que están en la misma ubicación en la misma semana, es decir, la matriz de adyacencia de wifi

Es importante ordenar la matriz e imputar los vacíos para que luego se pueda hacer producto de matrices con los sintomas.

```{r}
wlan_edges_by_week <- merge(wlan_by_week,
  wlan_by_week,
  by = c('week', 'location'),
  all.x = TRUE)

# eliminar el cruce de cada usuario con sigo mismo
wlan_edges_by_week <- wlan_edges_by_week %>%
                          filter(user_id.x != user_id.y) %>%
                          arrange(week, user_id.x, user_id.y)

wlan_edges_by_week
```
Para la cuenta de la intensidad de la relación se asume el mínimo de las relaciones de los dos extremos, ya que vienen de contar todas las "horas" que ha estado una persona en un área wifi, y por lo tanto, lo que han coincidido dos personas es la intersección, es decir, el mínimo del total de horas.

```{r}
wlan_edges_by_week <- wlan_edges_by_week %>% rowwise() %>% transmute(
                              week = week,
                              user_id.x = user_id.x,
                              user_id.y = user_id.y,
                              weight = min(count.x, count.y),
                      ) %>% 
                      group_by(week, user_id.x, user_id.y) %>%
                      summarise(weight = sum(weight))
wlan_edges_by_week
```
Imputamos ahora los datos faltantes para tener la matriz cuadrada. Para ello rellenamos con ceros los pares que falten:

```{r}
data.frame(
  "sujetos en el mapa de wifis" = length(unique(wlan_edges_by_week$user_id.x)),
  "sujetos totales" = length(unique(subjects$user_id))
)
```
Creamos la rejilla completa, con semanas desde la 40 hasta la 70 y todos los pares de usuarios y pesos 0

```{r}
grid.weeks <- 40:70
grid.users <- subjects$user_id
wifi_full_grid <- expand.grid(week = grid.weeks, user_id.x = grid.users, user_id.y = grid.users)
wifi_full_grid$weight = 0

wifi_full_grid <- wifi_full_grid %>%
                  full_join(wlan_edges_by_week) %>%
                  group_by(week, user_id.x, user_id.y) %>%
                  summarise(weight = max(weight)) %>%
                  ungroup()
wifi_full_grid %>% filter(weight > 0)
```

Ahora, desde la matriz de arcos de grafo completa, intentamos construir la matriz de adyacencia mediante un giro/pivotado de los datos:

```{r}
wlan_adjacency_by_week <- wifi_full_grid %>% pivot_wider(names_from = user_id.y, values_from = weight, values_fill = 0)
wlan_adjacency_by_week
```

Pintamos la matriz de adyacencia como grafo, para una semana, la información de las ubicaciones la hemos perdido al agregarla:

```{r}
library(network)

sel_week <- 66

edges <- wlan_edges_by_week %>% 
          ungroup %>%
          filter(week == sel_week) %>%
          dplyr::select(user_id.x, user_id.y, weight) %>%
          transmute(
            from =user_id.x,
            to = user_id.y,
            weight = weight 
          ) %>% filter(weight > mean(weight))

nodes <- unique(subjects %>% dplyr::select(user_id))

routes_network <- network(edges, vertex.attr = nodes, matrix.type = "edgelist", ignore.eval = FALSE)
plot(routes_network, vertex.cex = 1, mode = "circle", main = paste0("Semana ", sel_week))
```

Guardamos la matriz de adyacencia de Wifi para poder determinar las relaciones entre personas por cada semana en la tabla final del modelo.

```{r}
saveRDS(wlan_adjacency_by_week, "wlan_adjacency_by_week.RData")
write.csv(wlan_adjacency_by_week, "wlan_adjacency_by_week.csv", row.names = FALSE)
```





