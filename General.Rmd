---
title: "General"
author: "Miguel Pérez Barrero"
date: "25/11/2020"
output: word_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Carga de librerías

```{r}
library(reticulate)
```

## Referencias

1. Principal Component Analysis and k-means Clustering to Visualize a High Dimensional Dataset 
  url = https://medium.com/@dmitriy.kavyazin/principal-component-analysis-and-k-means-clustering-to-visualize-a-high-dimensional-dataset-577b2a7a5fe2
  fecha = Feb 21, 2019·5 min read
  autor = Dmitriy Kavyazin
  nivel = básico
  calibre = z:202011221253
  comentarios = {
    Contiene código en python para hacer el PCA y el Kmeans.
  }
2. How to Combine PCA and K-means Clustering in Python?
  url = https://365datascience.com/pca-k-means/
  nivel = intermedio
  calibre = z:202011221255
  comentarios = {
    Contiene código en python y buenos gráficos, explica un poco como hacer
    la separación de clusters y visualizarla.
  }
3. Para predecir con k-vecinos
  url = https://www.rdocumentation.org/packages/clue/versions/0.3-57/topics/cl_predict
  comentarios = {
    
  }

4. Libreria reticulate
  url = https://rstudio.github.io/reticulate/
  
5. Network analysis with R
  url = https://www.jessesadler.com/post/network-analysis-with-r/
  
6. Static and dynamic network visualization with R
  url = https://kateto.net/network-visualization
  
7. Render Pandas dataframe in RMarkdown
  url = https://stackoverflow.com/questions/60557226/render-pandas-table-in-r-markdown

8. Clustering algorithms with python
  url = https://machinelearningmastery.com/clustering-algorithms-with-python/
  
9. RSSI-based Localization Zoning using K-Mean Clustering
  calibre = SI
  url = https://iopscience.iop.org/article/10.1088/1757-899X/705/1/012038/pdf
  
10. Choosing the Best Clustering Algorithms, Datanovia
  url = https://www.datanovia.com/en/lessons/choosing-the-best-clustering-algorithms/
  
11. Tutorial: Self Organizing Maps in R
  url = https://www.polarmicrobes.org/tutorial-self-organizing-maps-in-r/
  
12. Introduction Self-Organizing Maps (SOM)
  url = https://rpubs.com/inayatus/som

## Quest log

IMPORTANTE: para los clusters en altas dimensiones mirar las varianzas en cada dimension y si son muy diferentes el KMeans no es muy efectivo [ver referencia 8].

* Hacer ANOVA para ver cuanto contribuye cada variable.
  Ubicación por WLAN
  Ubicación por Bluetooth
  Llamadas
  SMS
* [TODO] En los datos de WLAN hay muchos ceros en el tiempo de los eventos: mirarlo y limpiarlo
    - En el árticulo he visto que se usa una semana sola para separar las wifis según su ubicación, no el agregado de todas las semanas.
* [TODO] Crear la rejilla general de tiempo y ajustar los eventos medidos a ella (ubicación)
* [TODO] Estudiar la gripe:
    - Crear rejilla semanal
    - Comparar gráficamente y mediante un método espacial (analisis 2) la similitud de la evolución de los usuarios.
      - Detectar si hay evoluciones "desplazadas un ciclo".
    [TODO] Hacer un MCA entre sintomas y usuarios.
      Al final parece que un NDS nos vale, pero sale con mucho stress y a lo mejor conviene desagregar los datos más, por dia en lugar de por semana (interpolando)
      una vez clusterizados los usuarios después de hacer el nds, se hace un grafo con arcos entre los que estén en el mismo cluster.


Para generar la matriz de datos principales del modelo.

Cada fila representa 

3 periodos(semanas) de wlan
3 periodos(semanas) de bluetooth
3 periodos(semanas) de llamadas/sms (combinamos las dos)
3 periodos de friendship
3 periodos de activity
columnas "estáticas"
  year (subjects)
  floor (subjects)
sintomas
  fever
  sore
  runnynose
  nausea
  sad
  stressed
  
  
para cada Sintoma S
para cada periodo de sintomas P, para cada usuario U
[
  (p-3..p-1).each{|q| WLAN(week = q, user_id=U)*Sintoma(S, week = q) }
  (p-3..p-1).each{|q| BT(week = q, user_id=U)*Sintoma(S, week = q)}
  (p-3..p-1).each{|q| CALLSMS(week = q, user_id=U)*Sintoma(S, week = q)}
  (p-3..p-1).each{|q| ACTIVITY(week = q, user_id=U)*Sintoma(S, week = q)}
  (p-3..p-1).each{|q| Friendship(week = q, user_id=U)*Sintoma(S, week = q)}
  U.year
  U.floor
  S
]

Que matrices tenemos
  W


